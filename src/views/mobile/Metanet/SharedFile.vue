<template>
  <div class="w-full h-full" :style="{
    background: '#404A66',
  }">
    <div v-if="lockPageLoading" class="w-full h-full relative">
      <div class="absolute inset-0 bg-white opacity-10"></div>
      <div class="absolute top-16 inset-x-0 text-center pt-28">
        <van-loading size="40" color="#0094ff" vertical>Âä†ËΩΩ‰∏≠...</van-loading>
      </div>
    </div>
    <div v-else class="w-full h-full relative">
      <header class="h-11 px-4 flex items-center text-white">
        <div @click="onClickLogo">
          <!-- v-html="svgStr" -->
          <div>
            <MSvgIcon icon="logoWhiteBorder" :size="22.1" />
          </div>
        </div>
        <div class="flex-1 text-center flex items-center justify-center font-14 relative">
          üìÖ
          <span class="mr-1">{{ insertedAtText }}</span>
          ‚è≥
          <span>{{ expiredText }}</span>
          <div
            class="absolute-center-y right-4"
            :style="{
              'font-size': '22px',
            }"
          >
            <MLocaleSwither class="cursor-pointer font-20 text-white" />
          </div>
        </div>
        <div @click="onUserIconClick" class="flex-center">
          <!-- Â§¥ÂÉè -->
          <div
            v-if="isUserLoggedIn"
            class="rounded-full w-5 h-5 flex items-center justify-center text-white font-12"
            :style="{
              border: '.5px solid white',
              background:
                'linear-gradient(45deg, rgb(0, 172, 193), rgb(0, 213, 226))',
            }"
          >{{ myInfo.userName[0].toUpperCase() }}</div>
          <van-icon v-else color="#fff" size="20px" name="user-circle-o" />
        </div>
        <!-- <div @click="onShowRightPopup">
          <van-icon
            :style="{
              transform: 'rotate(90deg)',
            }"
            size="24"
            color="white"
            name="more-o"
          />
        </div>-->
      </header>
      <template v-if="!isValid">
        <div>
          <van-empty image="error" description="ÂàÜ‰∫´Â∑≤ËøáÊúüÊàñÂ∑≤Ë¢´ÂèñÊ∂à" />
        </div>
      </template>
      <template v-if="isValid">
        <div
          class="absolute bg-white pt-10"
          :style="{
            top: '100px',
            bottom: '40px',
            left: '16px',
            right: '16px',
            'border-radius': '15px',
          }"
        >
          <div
            class="absolute inline-block w-7 h-7 flex items-center justify-center font-18"
            @click="onCollect"
            :style="{
              top: '-36px',
              left: 0,
            }"
          >
            <van-icon v-if="isCurrentShareCollected" name="star" color="orange" />
            <van-icon color="#fff" v-else name="star-o" />
          </div>
          <div
            class="absolute inline-block px-1 w-7 h-7 flex items-center justify-center"
            @click="onCollect"
            :style="{
              top: '-36px',
              right: 0,
              color: 'white',
            }"
          >
            <MSvgIcon icon="share" :size="18" />
          </div>

          <!-- Â§¥ÂÉè -->
          <div
            class="absolute rounded-full w-16 h-16 flex items-center justify-center text-white text-2xl mb-3"
            :style="{
              border: '1px solid white',
              top: '-32px',
              left: '50%',
              transform: 'translateX(-50%)',
              background:
                'linear-gradient(45deg, rgb(0, 172, 193), rgb(0, 213, 226))',
            }"
          >{{ userPreview.username[0].toUpperCase() }}</div>
          <div class="text-center font-semibold font-20 mx-3 mb-2">{{ userPreview.username }}</div>
          <div class="text-gray-400 text-center"></div>
          <template v-if="!isCodeResolved">
            <div class="px-6 mb-4">
              <van-field
                class="rounded-full"
                :style="{
                  border: '1px solid #E6E6E6',
                  'text-align': 'center',
                }"
                v-model="inputCode"
                input-align="center"
                placeholder="ËØ∑ËæìÂÖ•ËÆøÈóÆÁ†Å"
              />
            </div>
            <div class="px-6">
              <van-button
                block
                class="h-12"
                :style="{
                  'border-radius': '999px',
                }"
                size="normal"
                type="primary"
                :loading="isLoadingConfirmCode"
                :disabled="inputCode.length === 0"
                @click="onConfirmCode"
              >ÊèêÂèñÊñá‰ª∂</van-button>
            </div>
          </template>
          <template v-else>
            <div
              ref="fileTableRef"
              class="mx-1 rounded-full"
              :style="{
                padding: '2px 0px',
                border: '1px solid #f2f2f2',
              }"
            >
              <div v-if="isCurrentShareFolder" class="px-2 font-semibold">
                <!-- <div v-else>ÂÖ®ÈÉ®Êñá‰ª∂/3200/ÊâÄÂèëÁîüÁöÑ</div> -->
                <div class="flex items-center justify-center h-6">
                  <van-icon
                    size="16px"
                    class="mr-2.5"
                    name="info-o"
                    @click="onShowDescriptionPopup"
                    color="#404A66"
                  />
                  <div
                    class="flex-1 flex items-center whitespace-nowrap overflow-hidden overflow-x-scroll"
                    :style="{
                      transition: 'max-width .3s ease-in',
                      'max-width': shouldCollapseHistoryDirBar ? '0px' : '100%',
                    }"
                  >
                    <template v-for="(dir, idx) in historyDir" :key="dir.dirId">
                      <div
                        class="historyDirItem"
                        :class="{
                          'text-gray-400': idx === historyDir.length - 1,
                        }"
                        @click="onUpperLevel(idx)"
                      >{{ dir.dirName }}</div>
                      <span v-if="idx !== historyDir.length - 1" class="px-2 text-gray-400">></span>
                    </template>
                    <template v-if="isShowDescriptionModalFileNameInAddressBar">
                      <div class="historyDirItem">
                        <span class="px-2 text-gray-400">></span>
                        {{ currentDescriptionModalFileName }}
                      </div>
                    </template>
                  </div>
                  <van-icon
                    :class="{
                      'ml-2.5': !shouldCollapseHistoryDirBar,
                    }"
                    v-if="isUserLoggedIn"
                    color="#404A66"
                    size="16px"
                    name="edit"
                  />
                </div>
              </div>
              <!-- Â¶ÇÊûú‰∏çÊòØÊñá‰ª∂Â§π, ‰ø°ÊÅØÂõæÊ†á , ÁôªÂΩïÂêéÂä†ËØÑËÆ∫ÂõæÊ†á -->
              <div v-else class="flex items-center justify-center h-6">
                <!-- TODO detailInfo -->
                <van-icon
                  color="#404A66"
                  size="16px"
                  class="mr-2"
                  name="info-o"
                  @click="onShowDescriptionPopup"
                />
                <!-- ÁôªÂΩïÂêéÊòæÁ§∫ËØÑËÆ∫ÊåâÈíÆ -->
                <van-icon v-if="isUserLoggedIn" color="#404A66" size="16px" name="edit" />
              </div>
            </div>

            <!-- Êñá‰ª∂ÂàóË°® -->
            <div
              class="mt-1 relative"
              :style="{
                overflow: 'hidden',
                'overflow-y': 'scroll',
                height: 'calc(100% - 80px)',
              }"
            >
              <van-loading v-if="isLoadingListData" class="absolute top-6 listLoading" size="36px" />
              <template v-if="fileData.length === 0">
                <!-- <div class="pt-4 pl-4 text-gray-400 text-center">Á©∫Êñá‰ª∂Â§π</div> -->
                <van-empty description="Á©∫Êñá‰ª∂Â§π" />
              </template>
              <template v-else>
                <div
                  class="px-3 py-2 flex items-center fileItem"
                  v-for="record in fileData"
                  :key="record.id"
                >
                  <div class="mr-2 relative" @click="onItemIconClick(record)">
                    <MFileTypeIcon class="w-9 h-9" :type="record.userFile?.fileType" />
                    <div
                      v-if="isCanFilePreview(record)"
                      class="absolute text-white bottom-0 font-12 bg-gray-400 opacity-60 left-0 right-0 text-center"
                    >È¢ÑËßà</div>
                  </div>
                  <div class="flex-1 text-overflow-3 mr-2" @click="onItemNameClick(record)">
                    <div
                      class="font-medium text-overflow-2"
                    >{{ lastOfArray(record.userFile?.fullName??[]) }}</div>
                    <div class="font-12 text-gray-400 text-overflow-2">
                      <template v-if="record.userFile?.info.description">
                        <template
                          v-if="
                            cacheFormatDescription(
                              record.userFile?.info.description ?? ''
                            ).tagArr.length
                          "
                        >
                          <template
                            v-for="(tag, idx) in cacheFormatDescription(
                              record.userFile?.info.description ?? ''
                            ).tagArr"
                          >
                            <van-tag
                              v-if="tag"
                              :key="tag"
                              :color="TAG_COLOR_LIST[idx]"
                              class="mr-1"
                            >{{ tag }}</van-tag>
                          </template>
                        </template>
                      </template>
                    </div>
                  </div>
                  <div>
                    <div class="flex items-center font-12 mb-1">
                      <van-icon class="text-gray-500" size="14px" name="like" />
                      <span>66</span>
                    </div>
                    <div class="flex items-center font-12">
                      <van-icon color="#404A66" size="14px" name="chat-o" />
                      <span>66</span>
                    </div>
                  </div>
                  <div class="w-8 flex justify-end">
                    <div
                      v-if="!record.checked"
                      class="bg-gray-300 rounded-full w-2 h-2 mr-1.5"
                      @click="record.checked = true"
                    ></div>
                    <van-checkbox v-else checked-color="#404A66" v-model="record.checked" />
                  </div>
                </div>
              </template>
            </div>
          </template>
        </div>
        <!-- Â∑•ÂÖ∑Ê†è -->
        <transition name="no-mode-fade">
          <MFooterBar v-if="selectedRows.length">
            <div class="flex items-center">
              <!-- background-color: #E1F4FF; color: #06A7FF; -->
              <!-- ‰∏ãËΩΩ -->
              <!-- <div
                class="rounded-full w-12 h-12 flex-center mr-4"
                :style="{
                  'background-color': 'rgba(64, 74, 102,.2)',
                  color: '#404A66',
                }"
                @click="onDownload"
              >
                <MSvgIcon icon="download" :size="24" />
              </div>-->
              <van-button
                round
                :style="{
                  'background-color': 'rgba(64, 74, 102,.2)',
                  color: '#404A66',
                  border: 'none',
                }"
                class="h-12 w-12 mr-4 rounded-full"
                @click="onDownload"
                :loading="isLoadingDownloadData"
                color="#404A66"
              >
                <MSvgIcon icon="download" :size="24" />
              </van-button>
              <!-- background-color: #E1F4FF; color: #06A7FF; -->
              <!-- ÂéãÁº©‰∏ãËΩΩ -->
              <div
                class="rounded-full w-12 h-12 flex-center"
                :style="{
                  'background-color': 'rgba(64, 74, 102,.2)',
                  color: '#404A66',
                }"
              >
                <MSvgIcon icon="zip" :size="24" />
              </div>
            </div>

            <!-- ‰øùÂ≠ò -->
            <van-button
              round
              type="primary"
              class="h-12 w-32 font-semibold font-15 justify-self-end"
              @click="saveToMetanetModalPreAction"
              :loading="isLoadingDirData"
              color="#404A66"
            >‰øùÂ≠òÂà∞ÁΩëÁõò</van-button>
          </MFooterBar>
        </transition>
      </template>
    </div>
    <!-- ‰øùÂ≠òÂà∞ÁõÆÊ†áÊñá‰ª∂Â§πÂºπÁ™ó -->
    <van-popup v-if="isValid" v-model:show="popupState.isShow" round position="bottom">
      <van-cascader
        title="ËØ∑ÈÄâÊã©ÁõÆÊ†áÊñá‰ª∂Â§π"
        :field-names="{
          text: 'dirName',
          value: 'dirId',
          children: 'children',
        }"
        v-model="popupState.dirId"
        :options="dirData"
        close-icon="success"
        @close="onClosePopup"
        @change="onChangePopup"
      />
    </van-popup>
    <!-- ÁÇπÂáªÁöÑÊñá‰ª∂ÁöÑÂÖ®ÈÉ®ÊèèËø∞‰ø°ÊÅØ -->
    <van-popup
      round
      class="rounded p-4 font-14"
      v-model:show="isShowDescriptionPopup"
      @close="onCloseDescriptionPopup"
      :style="{
        width: '300px',
      }"
    >
      <!-- Ê†áÈ¢ò -->
      <div
        class="font-semibold text-center font-16 mb-2 text-overflow-3"
        :style="{
          'margin-top': '-8px',
        }"
      >{{ `${currentDescriptionModalFileName}` }}</div>
      <div
        :style="{
          'max-height': 'calc(100vh - 200px)',
          overflow: 'scroll',
        }"
      >
        <MMdParser v-if="currentDescription" :content="currentDescription" />
        <div v-else class="text-gray-400 text-center">Êó†ÊèèËø∞‰ø°ÊÅØ</div>
      </div>
    </van-popup>
    <!-- ‰∫åÁª¥Á†ÅÂºπÁ™ó -->
    <van-popup v-model:show="popupQrCodeVisible" round>
      <MQrCode :url="popupQrCodeAddr" :width="180" />
      <van-button type="primary">Á°ÆÂÆö</van-button>
    </van-popup>
    <!-- Âè≥ËæπÂ∑•ÂÖ∑Ê†è -->
    <!-- <van-popup
      v-model:show="isShowRightPopup"
      position="right"
      :style="{ height: '100%' }"
    >
      <div class="p-4 w-40 font-medium">
        <div @click="onCloseRightPopup" class="text-right mb-2">
          <van-icon name="cross" size="22px" />
        </div>
        <div
          v-if="isValid"
          @click="onCollect"
          class="py-3 w-20 flex items-center"
        >
          <van-icon class="mr-2" size="20px" name="star-o" />
          Êî∂Ëóè
        </div>
        <div
          @click="onLogIn"
          v-if="!isUserLoggedIn"
          class="py-3 w-20 flex items-center"
        >
          <van-icon class="mr-2" size="20px" name="user-circle-o" />
          ÁôªÂÖ•
        </div>
        <div
          @click="onLogOut"
          v-if="isUserLoggedIn"
          class="py-3 w-20 flex items-center"
        >
          <van-icon class="mr-2" size="20px" name="revoke" />
          ÁôªÂá∫
        </div>
      </div>
    </van-popup>-->
    <!-- Â∫ïÈÉ®È¢ÑËßàpdfÂºπÁ™ó -->
    <van-popup v-model:show="isShowBottomPopup" position="bottom" :style="{ height: '100%' }">
      <div class="h-14 flex items-center justify-between van-hairline--bottom">
        <div class="font-16 font-semibold pl-4">{{ currentPreviewPdfName }}</div>
        <div @click="onCloseBottomPopup" class="p-4">
          <van-icon name="cross" size="22px" />
        </div>
      </div>
      <div v-if="isLoadingPdf" class="absolute top-16 inset-x-0 text-center pt-28">
        <van-loading size="40" color="#0094ff" vertical>Âä†ËΩΩ‰∏≠...</van-loading>
      </div>
      <div
        v-else
        class="overflow-auto"
        :style="{
          height: 'calc(100% - 3.5rem)',
        }"
        id="pdfCanvas"
      ></div>
    </van-popup>
  </div>
</template>

<script setup lang="ts">
import {
  apiCollectCreateByShare,
  apiCollectDelete,
  apiDriveSaveShareFile,
  apiGetPreviewToken,
  apiPriviewSharedFile,
  apiQueryCollectList,
  apiLoopQueryFileByDir,
  apiQuerySharedFile,
  apiSecondUpload,
  QueryShareFileItem,
  TFileItem,
} from "../../../apollo/api";
import {
  getFileType,
  lastOfArray,
  formatBytes,
  cacheFormatDescription,
  DescObj,
  cacheFn,
  downloadFileByUrl,
  useDelay,
  transformRawDescription,
  makeFileUrl,
} from "../../../hooks";
import dayjs from "dayjs/esm";
import { Dialog, Toast } from "vant";
import {
  computed,
  defineComponent,
  nextTick,
  onMounted,
  onUnmounted,
  reactive,
  ref,
  watch,
} from "vue";
import { onBeforeRouteLeave, useRoute, useRouter } from "vue-router";
import {
  MFileTypeIcon,
  MSvgIcon,
  MMdParser,
  MLocaleSwither,
  MFooterBar,
  MQrCode,
} from "../../../components/mobile";
import { useBaseStore, useUserStore } from "../../../store";
import { FILE_TYPE_MAP, TAG_COLOR_LIST } from "../../../constants";
import pdfjsLib from "pdfjs-dist";
import { PDFDocumentProxy } from "pdfjs-dist/types/src/display/api";
import { onClickOutside } from "@vueuse/core";

type SelectedItem = {
  id: string;
  token: string;
};
type TDir = {
  dirId: string;
  dirName: string;
  parent: null | TDir;
  children?: TDir[];
};
type ListItem = {
  userFile: QueryShareFileItem["userFile"];
  checked: boolean;
  id: string; // ÂàÜ‰∫´ÁöÑid(Ê≤°ÊúâÂ∞±Áî®Á©∫)
  token: string;
};
type DetailInfo = {
  name: string;
  type: string;
  size: string;
  insertedAt: string;
  updatedAt: string;
  desc: DescObj;
};

const DETAIL_INFO_MAP = {
  name: "ÂêçÁß∞",
  type: "Á±ªÂûã",
  size: "Â§ßÂ∞è",
  insertedAt: "ÂàõÂª∫Êó∂Èó¥",
  updatedAt: "Êõ¥Êñ∞Êó∂Èó¥",
  desc: "ÊèèËø∞",
};

function sortByDirType(a: ListItem, b: ListItem) {
  return a.userFile?.isDir ? (b.userFile?.fullName[0] === "..." ? 1 : -1) : 1;
}

const isCanFilePreview = (record: ListItem) => {
  // Êñá‰ª∂Êàñpdf
  const f = record.userFile;
  if (!f) return false;
  const e = getFileType({
    isDir: f.isDir,
    fileName: lastOfArray(f.fullName),
  });
  if (FILE_TYPE_MAP.image.includes(e) || e === "pdf") {
    return true;
  }
  // ÂÖ∂‰ªñÁ±ªÂûãËøîÂõûfalse
  return false;
};

/** Êñá‰ª∂Â§πËØ¶ÊÉÖÁºìÂ≠ò,dirId‰Ωú‰∏∫key */
const idMapDescriptionCache = new Map<
  string,
  { fileName: string; descSource: string }
>();

// ÁôªÂΩïÂíåÊú™ÁôªÂΩïÁöÑ
// Êú™ÁôªÂΩïÁöÑÊòØÂèØ‰ª•ÁúãÁöÑ,‰ΩÜÊòØÁÇπÂáªÂäüËÉΩÂêéÂØºËà™ÂéªÁôªÂΩïÈ°µ,ÁôªÂΩïÂÆåÂÜçËøîÂõûÊù•
const baseStore = useBaseStore();
const lockPageLoading = ref(true);
const route = useRoute();
const router = useRouter();
const userStore = useUserStore();
const isValid = ref(true);
const currentUri = ref("");
const currentShareToken = ref("");
const currentShareId = ref("");
/** ÂΩìÂâçÁöÑÂàÜ‰∫´ÊòØÂê¶ÊòØÂçï‰∏™Êñá‰ª∂Â§π */
const isCurrentShareFolder = ref(false);
/** ÈÄâ‰∏≠ÁöÑÊñá‰ª∂ */
// const selectedRows = ref<SelectedItem[]>([]);
const selectedRows = computed(() =>
  fileData.value.filter((record) => record.checked)
);
/** Áî®Êà∑ËæìÂÖ•ÁöÑËÆøÈóÆÁ†Å */
const inputCode = ref("");
const userPreview = reactive({
  avatar: "",
  bio: "",
  email: "",
  username: "",
});
/**  ÈÄöËøáËÆøÈóÆÁ†ÅÊéßÂà∂‰∫ÜÊ≤° */
const isCodeResolved = ref(false);
/** *ÂêéËøáÊúü*/
const expiredText = ref("");
/** ÂàõÂª∫Êó∂Èó¥ */
const insertedAtText = ref("");
/** ÂΩìÂâçËøô‰∏™ÂàÜ‰∫´ÁöÑÊî∂ËóèÊï∞ */
const curShareCollectedCount = ref(0);
/** ÊòØÂê¶Ê≠£Âú®Âä†ËΩΩÂàóË°®‰∏≠ÁöÑÊï∞ÊçÆ */
const isLoadingListData = ref(false);
const fileData = ref<ListItem[]>([]);
const isLoadingConfirmCode = ref(false);
/** ÂΩìÂâçÁöÑÂàÜ‰∫´ÊòØÂê¶Êî∂ËóèËøá */
const isCurrentShareCollected = ref(false);
/** ÁÇπÂáªÊèêÂèñÊñá‰ª∂ */
const onConfirmCode = () => {
  if (!inputCode.value.length) {
    Toast("ËØ∑ËæìÂÖ•ËÆøÈóÆÁ†Å");
    return;
  }
  isLoadingConfirmCode.value = true;
  getSetFileData().finally(() => {
    isLoadingConfirmCode.value = false;
  });
};
//  name: lastOfArray(e.fullName),
//     type: getFileType({
//       isDir: e.isDir,
//       fileName: lastOfArray(e.fullName),
//     }),
//     size: formatBytes(+showSize),
//     insertedAt: dayjs(e.insertedAt).format("YYYYÂπ¥MMÊúàDDÊó•hh:mm"),
//     updatedAt: dayjs(e.updatedAt).format("YYYYÂπ¥MMÊúàDDÊó•hh:mm"),
//     desc: cacheFormatDescription(e.info.description || ""),

const isUserLoggedIn = computed(() => userStore.isLoggedIn);
/** Ê£ÄÊü•Êú™ÁôªÂΩïÂπ∂Ë∑≥ËΩ¨Âà∞ÁôªÂΩïÈ°µ */
const checkLoginStatusThenOpenPopupLogin = () => {
  if (!isUserLoggedIn.value) {
    baseStore.changeIsShowLoginModal(true);
    // router.push({
    //   name: "Login",
    //   query: { redirect: route.fullPath },
    // });
    return true;
  }
  return false;
};
const myInfo = computed(() => {
  const userName = userStore.username;
  return { userName };
});
/** logoÁöÑÁÇπÂáª */
const onClickLogo = () => {
  if (!isUserLoggedIn.value) {
    router.push({
      name: "Login",
    });
  } else {
    // Â∑≤ÁªèÁôªÂΩïÂ∞±Ë∑≥ËΩ¨Âà∞account
    router.push("/account");
  }
};
/** header Âè≥ËæπÂ§¥ÂÉèÁöÑÁÇπÂáª */
const onUserIconClick = () => {
  if (checkLoginStatusThenOpenPopupLogin()) {
    return;
  }
  // Â∑≤ÁªèÁôªÂΩïÂ∞±Ë∑≥ËΩ¨Âà∞account
  router.push("/account");
};
/** Êî∂Ëóè */
const onCollect = async () => {
  if (checkLoginStatusThenOpenPopupLogin()) {
    return;
  }
  if (isCurrentShareCollected.value) {
    Toast("ÂèñÊ∂àÊî∂ËóèTODO");
    // const res = await apiCollectDelete({ id: currentShareId.value });
    // if (res.err || !res.data) {
    //   return;
    // }
    // isCurrentShareCollected.value = false;
    // Toast("ÂèñÊ∂àÊî∂ËóèÊàêÂäü");
  } else {
    const res = await apiCollectCreateByShare({ id: currentShareId.value });
    if (res.err || !res.data) {
      return;
    }
    isCurrentShareCollected.value = true;
    curShareCollectedCount.value += 1;
    Toast("Êî∂ËóèÊàêÂäü!");
  }
};
const isLoadingDownloadData = ref(false);
/** ‰∏ãËΩΩ */
const onDownload = () => {
  // if (checkLoginStatusThenOpenPopupLogin()) {
  //   return;
  // }
  // console.log("onDownload");
  selectedRows.value.forEach((record) => {
    if (!record.userFile) return;
    const {
      user,
      fullName,
      space,
      id: fileId,
      updatedAt,
    } = record.userFile;
    const downloadToken = record.token;
    // apiGetPreviewToken().then((resultPreviewToken) => {
    // if (resultPreviewToken.err) return;
    useDelay(100).then(() => {
      if (!record.userFile) return;
      // const token = resultPreviewToken.data.drivePreviewToken;
      // const url = `https://drive-s.owaf.io/download/${
      //   user.id
      // }/${space.toLowerCase()}/${fileId}/${
      //   fullName.slice(-1)[0]
      // }?token=${downloadToken}&t=${dayjs(record.userFile.updatedAt).format(
      //   "YYYYMMDDHHmmss"
      // )}`;
      const url = makeFileUrl({
        urlType: "download",
        token: downloadToken,
        userId: user.id,
        space: space.toLowerCase(),
        fileId,
        fileName: fullName.slice(-1)[0],
        updateAt: updatedAt,
      });

      downloadFileByUrl({
        url,
        fileName: fullName.slice(-1)[0],
        onBeforeFetch: () => {
          isLoadingDownloadData.value = true;
        },
        onAfterFetch: () => {
          isLoadingDownloadData.value = false;
        },
      });
    });
    // });
  });
};
/** ‰øùÂ≠òÂà∞ÁΩëÁõò */
const saveToMetanetModalPreAction = () => {
  if (checkLoginStatusThenOpenPopupLogin()) {
    return;
  }
  getSetSaveToMetanetModalTableData().then(() => {
    // open popup
    popupState.isShow = true;
    // Ê∏ÖÁ©∫‰∏ä‰∏ÄÊ¨°ÁöÑÈÄâÊã©
    clearPopupSelectedDir();
  });
  // console.log("saveToMetanetModalPreAction");
};
const onUpperLevel = (dirIdx: number) => {
  // 1. Â¶ÇÊûúÁÇπÁöÑÊòØÂΩìÂâçÊñá‰ª∂Â§π
  if (dirIdx === historyDir.value.length - 1) {
    // 1.1 Â¶ÇÊûúÊúâ ÊèèËø∞Êñá‰ª∂Ê†è
    if (isShowDescriptionModalFileNameInAddressBar.value) {
      isShowDescriptionModalFileNameInAddressBar.value = false;
      const _dirId = historyDir.value[dirIdx].dirId;
      setCurrentDescriptionModalDataFromCache(_dirId);
    } else if (dirIdx === 0) {
      // 1.2 Â¶ÇÊûúÊ≤°Êúâ ÊèèËø∞Êñá‰ª∂Ê†è ‰∏îÊòØÊ†πÁõÆÂΩï, Êî∂Ëµ∑ÊâÄÊúâÂú∞ÂùÄÊ†è
      shouldCollapseHistoryDirBar.value = true;
      useDelay(300).then(() => {
        historyDir.value.length = 0;
      });
      getSetFileData();
      setCurrentDescriptionModalDataFromCache(firstFolderDirId);
    }
  } else {
    // 2. Â¶ÇÊûúÁÇπÁöÑ‰∏çÊòØÂΩìÂâçÊñá‰ª∂Â§π
    // 2.1 Â¶ÇÊûúÊúâ ÊèèËø∞Êñá‰ª∂Ê†è
    if (isShowDescriptionModalFileNameInAddressBar.value) {
      isShowDescriptionModalFileNameInAddressBar.value = false;
      const _dirId = historyDir.value[dirIdx].dirId;
      setCurrentDescriptionModalDataFromCache(_dirId);
    }
    historyDir.value.splice(dirIdx + 1);
    const dirId = lastOfArray(historyDir.value).dirId;
    getSetDriveList(dirId);
    setCurrentDescriptionModalDataFromCache(dirId);
  }
};
const dirData = ref<TDir[]>([]);
const isLoadingDirData = ref(false);
/** ÈÄíÂΩíËØ∑Ê±ÇËÆæÁΩÆÁõÆÂΩïÊï∞ÊçÆ */
const getSetSaveToMetanetModalTableData = () => {
  return new Promise<void>((resolve) => {
    dirData.value.length = 0;
    isLoadingDirData.value = true;
    // 2021-07-05 ÂÖàÈÄíÂΩíÂ§ÑÁêÜÊâÄÊúâÁöÑÁõÆÂΩï, ÂêéÁª≠Ë¶ÅÊåâÈúÄÂä†ËΩΩ
    apiLoopQueryFileByDir({
      fileType: "DIR",
      dirId: "root",
      startPage: 1,
    }).then(async (resultQueryFile) => {
      if (resultQueryFile.err) {
        // console.log("err", err);
        isLoadingDirData.value = false;
        return;
      }
      /** Ê†πÊçÆÁõÆÂΩïid, Áà∂ÁõÆÂΩïid ÂéªÈÄíÂΩíËé∑Âèñchildren */
      const getAndSetDirChildren = async (item: TDir) => {
        const parentId = item.parent?.dirId;
        // const [resItem, errItem] = await apiLoopQueryFileByDir({
        const resultQueryFileItem = await apiLoopQueryFileByDir({
          fileType: "DIR",
          dirId: item.dirId,
          startPage: 1,
        });
        // console.log("ÁõÆÂΩïres", item.dirId, item.dirName, resItem);
        if (resultQueryFileItem.err) return item;
        // ÊéíÈô§ ÈùûÁõÆÂΩïÊñá‰ª∂/ Ê†πÁõÆÂΩï/ Ëá™Ë∫´/ Áà∂ÁõÆÂΩï(‰∏ä‰∏ÄÁ∫ß)
        const afterFilterList =
          resultQueryFileItem.data.driveListFiles.filter(
            (i): i is TFileItem =>
              i !== null &&
              i.isDir &&
              !["root", item.dirId, parentId].includes(i.id)
          );
        // console.log("afterFilterList", afterFilterList);
        if (!afterFilterList.length) return item;
        item.children = await Promise.all(
          afterFilterList.map((i) =>
            getAndSetDirChildren({
              dirId: i.id,
              dirName: lastOfArray(i.fullName),
              parent: item,
            })
          )
        );
        return item;
      };
      // res.data.driveListFiles ÊèêÂèñÊñá‰ª∂Â§πÁöÑÂá∫Êù•
      const resIsDirList = resultQueryFile.data.driveListFiles.filter(
        (i): i is TFileItem => i !== null && i.isDir && i.id !== "root"
      );
      const withChildrensDirList = await Promise.all(
        resIsDirList.map((i) =>
          getAndSetDirChildren({
            dirId: i.id,
            dirName: lastOfArray(i.fullName),
            parent: {
              dirId: "root",
              dirName: "root",
              parent: null,
            },
          })
        )
      );
      const rootDir: TDir = {
        dirId: "root",
        dirName: "ÂÖ®ÈÉ®Êñá‰ª∂",
        parent: null,
        children: withChildrensDirList,
      };
      dirData.value.push(rootDir);
      isLoadingDirData.value = false;
      resolve();
    });
  });
};
const popupState = reactive<{
  isShow: boolean;
  dirId: string;
  dirFullName: string[];
}>({
  isShow: false,
  dirId: "",
  dirFullName: [],
});
/** Ê∏ÖÁ©∫‰∏ä‰∏ÄÊ¨°ÁõÆÊ†áÊñá‰ª∂Â§πÈÄâÊã© */
const clearPopupSelectedDir = () => {
  popupState.dirId = "";
  popupState.dirFullName = [];
};
const onChangePopup = ({
  selectedOptions,
}: {
  selectedOptions: { dirId: string; dirName: string }[];
}) => {
  // console.log("onChangePopup", selectedOptions);
  popupState.dirFullName = selectedOptions.map((i) => i.dirName);
};
const onClosePopup = () => {
  // console.log("ÂÖ≥Èó≠ÂºπÁ™ó", popupState);
  popupState.isShow = false;
  if (popupState.dirId) {
    Dialog.confirm({
      message: `ÊòØÂê¶‰øùÂ≠òÂà∞"${popupState.dirFullName.join("/")}"?`,
      beforeClose: (action) =>
        new Promise((resolve) => {
          // Â¶ÇÊûúÊòØÂèñÊ∂àÊìç‰Ωú,ÊèêÂâçÈÄÄÂá∫
          if (action !== "confirm") {
            resolve(true);
            return;
          }
          const folderFullName = popupState.dirFullName.slice(1); // ‰∏çÁî®‰º†Á¨¨‰∏Ä‰∏™Ê†πÁõÆÂΩï
          Promise.all(
            selectedRows.value.map((i) => {
              if (!i.userFile) return;
              // return apiSecondUpload({
              //   // ÂåÖÂê´Ë¶Å‰øùÂ≠òÁöÑË∑ØÂæÑÁöÑÊñá‰ª∂ÂÖ®ÂêçÊï∞ÁªÑ
              //   fullName: [
              //     ...folderFullName,
              //     lastOfArray(i.userFile.fullName),
              //   ],
              //   description: i.userFile.info.description || "",
              //   fileHash: i.userFile.hash || "",
              // });
              return apiDriveSaveShareFile({
                code: inputCode.value,
                fromUserFileId: i.userFile.id,
                id: currentShareId.value,
                toUserFileId: popupState.dirId,
              });
            })
          ).finally(() => {
            Toast.success("‰øùÂ≠òÊàêÂäü");
            resolve(true);
          });
        }),
    });
  }
};
/**  */
/** Âè≥ËæπÁöÑÂºπÂ±Ç */
// function useRightPopup() {
//   const isShowRightPopup = ref(false);
//   const onShowRightPopup = () => {
//     isShowRightPopup.value = true;
//   };
//   const onCloseRightPopup = () => {
//     isShowRightPopup.value = false;
//   };
//   const onLogIn = () => {
//     router.push({
//       name: "Login",
//       query: { redirect: route.fullPath },
//     });
//   };
//   const onLogOut = () => {
//     localStorage.clear();
//     window.location.reload();
//   };
//   return {
//     isShowRightPopup,
//     onShowRightPopup,
//     onCloseRightPopup,
//     onLogIn,
//     onLogOut,
//   };
// }
/** ÊòØÂê¶Ê≠£Âú®Âä†ËΩΩpdf */
const isLoadingPdf = ref(false);
const isShowBottomPopup = ref(false);
/** ÂΩìÂâçÈ¢ÑËßàÁöÑpdfÁöÑÊñá‰ª∂Âêç */
const currentPreviewPdfName = ref("");
/** Â∫ïÈÉ®ÁöÑÂºπÂ±Ç */
const onShowBottomPopup = () => {
  isShowBottomPopup.value = true;
};
const onCloseBottomPopup = () => {
  isShowBottomPopup.value = false;
  currentPreviewPdfName.value = "";
};

/** ÂΩìÂâçÊâìÂºÄÁöÑÁ¨¨‰∏Ä‰∏™Êñá‰ª∂Â§πÁöÑid */
let firstFolderDirId = "0";
// const onFinishPopup = () => {
//   console.log("onFinishPopup", popupState);
// };
/** Ëé∑ÂèñÊñá‰ª∂‰ø°ÊÅØ */
const getSetFileData = async () => {
  isLoadingListData.value = true;
  const { data, err } = await apiQuerySharedFile({
    uri: currentUri.value,
    ...(!isCodeResolved.value || inputCode.value
      ? {
        code: inputCode.value,
      }
      : {}),
  });
  isLoadingListData.value = false;
  if (err || !data) return;
  if (data.driveFindShare === null) {
    Toast("ËÆøÈóÆÁ†ÅÈîôËØØ");
    return;
  }
  if (data.driveFindShare.userFile === null) {
    // Áî®Êà∑ Âà†Èô§ÂéüÊñá‰ª∂
    console.log("userFile‰∏∫null,Êù•Ê∫êÁî®Êà∑Âà†Èô§‰∫ÜËØ•Êñá‰ª∂");
    isValid.value = false;
    return;
  }
  // Ê≥®ÂÜåÂΩìÂâçÂàÜ‰∫´ÁöÑtoken
  currentShareToken.value = data.driveFindShare.token;
  currentShareId.value = data.driveFindShare.id;
  isCurrentShareFolder.value = data.driveFindShare.userFile.isDir;
  const e = data.driveFindShare.userFile;
  if (isCurrentShareFolder.value) {
    firstFolderDirId = data.driveFindShare.userFile.id;
    useClickOutSideWhenShareIsFolder();
  }
  // Áõ¥Êé•Ê≥®ÂÜåËØ¶ÊÉÖ
  setCurrentDescriptionModalData(
    e.id,
    lastOfArray(e.fullName),
    e.info.description || ""
  );
  // Êü•ËØ¢ÂΩìÂâçÂàÜ‰∫´ÊòØÂê¶Êî∂ËóèËøá
  // isCurrentShareCollected
  apiQueryCollectList({ type: "SHARE" }).then((res) => {
    if (res.data) {
      isCurrentShareCollected.value = res.data.driveListCollections.some(
        (i) => i.item?.id === data.driveFindShare.id
      );
    }
  });
  curShareCollectedCount.value = data.driveFindShare.collectedCount;
  // ÊääÁî®Êà∑ËæìÂÖ•ËøáÁöÑÂ≠òÂà∞sessionStorage Èáå
  sessionStorage.setItem(currentUri.value, inputCode.value);
  fileData.value.length = 0;
  fileData.value.push({
    // ÊîπÂèòfullname ÂíåfileType
    ...data.driveFindShare,
    userFile: {
      ...data.driveFindShare.userFile,
      fullName: data.driveFindShare.userFile.fullName.slice(-1),
      fileType: getFileType({
        isDir: data.driveFindShare.userFile.isDir,
        fileName: lastOfArray(data.driveFindShare.userFile.fullName),
      }),
    },
    checked: false,
  });
  // console.log("fileData", fileData);
  isValid.value = true;
  isCodeResolved.value = true;
};
/** ÁõÆÂΩïÈù¢ÂåÖÂ±ë
 * ÂΩìÁÇπÂáªÁ¨¨‰∏Ä‰∏™ÁöÑÊó∂ÂÄôÊòØÁî®share ÁöÑapi,ÊâÄ‰ª•ËøôÈáåÁ¨¨‰∏Ä‰∏™dirId‰∏ç‰ºöË¢´Áî®Âà∞ */
const historyDir = ref<{ dirId: string; dirName: string }[]>([
  // { dirId: "none", dirName: "/" },
  // ÈªòËÆ§Êîπ‰∏∫Á©∫ÁöÑ
]);
/** ÊòØÂê¶ÊäòÂè†Ë∑ØÂæÑÊ†è */
const shouldCollapseHistoryDirBar = ref(false);
/** Âú∞ÂùÄÊ†èÁöÑÊúÄÂêé‰∏Ä‰∏™ÂÖÉÁ¥†ÊªëÂä®ËøõÂÖ•ËßÜÂõæ */
const scrollLastAddressItemIntoView = () => {
  const lastHistoryDirItemElement = [
    ...document.querySelectorAll(".historyDirItem"),
  ].pop();
  // console.log("lastHistoryDirItemElement", lastHistoryDirItemElement);
  // Âú∞ÂùÄÊ†èÊúÄÂêé‰∏Ä‰∏™ËøõÂÖ•ËßÜÂõæ
  if (lastHistoryDirItemElement) {
    lastHistoryDirItemElement.scrollIntoView({
      behavior: "smooth",
    });
  }
};
watch(
  () => historyDir.value,
  (newVal) => {
    // console.log("newVal", newVal);
    if (!newVal.length) {
      shouldCollapseHistoryDirBar.value = true;
    } else {
      shouldCollapseHistoryDirBar.value = false;
    }
    useDelay(0).then(scrollLastAddressItemIntoView);
  },
  { immediate: true, deep: true }
);
onMounted(() => {
  const queryUri = route.query.uri as string;
  // console.log("queryUri", queryUri);
  if (!queryUri) return;
  currentUri.value = queryUri;
  apiPriviewSharedFile({ uri: queryUri }).then(({ data, err }) => {
    if (err || !data || !data.drivePreviewShare) {
      isValid.value = false;
      lockPageLoading.value = false;
      return;
    }
    const { userPreview: resUserPreview } = data.drivePreviewShare;
    // Ê≥®ÂÜå ÂàÜ‰∫´Êù•Ê∫êÁî®Êà∑ÁöÑ‰ø°ÊÅØ
    userPreview.avatar = resUserPreview.avatar || "";
    userPreview.bio = resUserPreview.bio;
    userPreview.email = resUserPreview.email;
    userPreview.username = resUserPreview.username;
    // Â¶ÇÊûúÊñá‰ª∂ÈúÄË¶ÅËÆøÈóÆÁ†Å, Âàô ËÆøÈóÆÁ†ÅÊéßÂà∂false,Á≠âÂæÖÂêéÈù¢ËæìÂÖ•
    isCodeResolved.value = !data.drivePreviewShare.needCode;
    const diffNow = dayjs(data.drivePreviewShare.expiredAt).diff(dayjs());
    // Â¶ÇÊûúÊñá‰ª∂ËøáÊúü‰∫Ü
    if (diffNow < 0) {
      isValid.value = false;
      lockPageLoading.value = false;
      return;
    }
    expiredText.value = `${dayjs(data.drivePreviewShare.expiredAt).diff(
      dayjs(),
      "days"
    )}Â§©ÂêéËøáÊúü`;
    insertedAtText.value = dayjs(data.drivePreviewShare.insertedAt).format(
      "YY-MM-DD"
    );
    // Â¶ÇÊûú‰∏çÈúÄË¶ÅËÆøÈóÆÁ†Å, Á´ãÂç≥ËØ∑Ê±ÇÊñá‰ª∂
    if (isCodeResolved.value === true) {
      getSetFileData().finally(() => {
        lockPageLoading.value = false;
      });
    } else if (sessionStorage.getItem(queryUri)) {
      // Â¶ÇÊûúsessionStorage ÈáåÊúâuri , ÊãøÂá∫Êù•Áî®
      inputCode.value = sessionStorage.getItem(queryUri) as string;
      getSetFileData().finally(() => {
        lockPageLoading.value = false;
      });
    } else {
      lockPageLoading.value = false;
    }
  });
});
const getSetDriveList = (dirId: string) => {
  const token = currentShareToken.value;
  isLoadingListData.value = true;
  apiLoopQueryFileByDir({
    dirId,
    token,
    startPage: 1,
  }).then((res) => {
    isLoadingListData.value = false;
    if (res.err || !res.data) {
      return;
    }
    fileData.value.length = 0;
    res.data.driveListFiles.forEach((item) => {
      if (!item || item.id === dirId || item.fullName.length === 0) return;
      fileData.value.push({
        id: item.id,
        checked: false,
        token: currentShareToken.value,
        userFile: {
          ...item,
          fileType: getFileType({
            isDir: item.isDir,
            fileName: lastOfArray(item.fullName),
          }),
        },
      });
    });
    fileData.value.sort(sortByDirType);
  });
};
let destoryPdfLoadingTask: (() => void) | null = null;
/** ÁÇπÂáªicon */
const onItemIconClick = async (record: ListItem) => {
  // console.log("onItemIconClick", record);
  // if (notLoggedInAndRoute()) {
  //   console.log("Êú™ÁôªÂΩï,Ë∑≥ËΩ¨");
  //   return;
  // }
  // if (FILE_TYPE_MAP.image.includes(e)) return image;
  if (!record.userFile) return;
  const fileType = getFileType({
    isDir: record.userFile.isDir,
    fileName: lastOfArray(record.userFile.fullName),
  });
  if (/folder$/g.test(fileType)) {
    // 1.ÊòØÊñá‰ª∂Â§π
    // 1.1 change historyDir
    historyDir.value.push({
      dirId: record.userFile.id,
      dirName: lastOfArray(record.userFile.fullName),
    });
    getSetDriveList(record.userFile.id);
    isShowDescriptionModalFileNameInAddressBar.value = false;
    // 1.2 change fileData
  } else if (FILE_TYPE_MAP.image.includes(fileType)) {
    // 2.ÊòØÂõæÁâá
    const { user, space, id: fileId, fullName } = record.userFile;
    // ÂàÜ‰∫´ÁöÑÈ¢ÑËßàÁî®ÁöÑtoken ÊòØËØ•ÂàÜ‰∫´Êï∞ÊçÆÁöÑtoken
    const token = record.token;
    const tableImgList = fileData.value.filter(
      (item) =>
        item.userFile !== null &&
        FILE_TYPE_MAP.image.includes(item.userFile.fileType ?? "")
    );
    const toPreviewList = tableImgList.map((item) => ({
      src: makeFileUrl({
        urlType: "preview",
        token: token,
        userId: item.userFile?.user.id ?? "",
        space: item.userFile?.space ?? "",
        fileId: item.userFile?.id ?? "",
        fileName: item.userFile?.fullName.slice(-1)[0] ?? "",
        updateAt: item.userFile?.updatedAt ?? "",
      }),
      w: 0,
      h: 0,
      title: item.userFile?.info.description
        ? transformRawDescription(item.userFile?.info.description)
        : "",
    }));
    // ÊâæÂá∫ÂΩìÂâçÁÇπÂáªÁöÑÂõæÁâáÁöÑ openIndex
    const startImgIdx = tableImgList.findIndex((i) => i.id === record.id);
    baseStore.setPhotoSwipeAndShow(toPreviewList, { index: startImgIdx });
  } else if (fileType === "pdf") {
    // ÂÖàÊ∏ÖÁêÜ‰∏ä‰∏ÄÊ¨°ÁöÑ‰ªªÂä°(Â¶ÇÊûúÊúâ)
    if (destoryPdfLoadingTask) {
      destoryPdfLoadingTask();
    }
    // console.log("pdf-Á±ªÂûã");
    const { user, space, id: fileId, fullName } = record.userFile;
    const token = record.token;
    // const pdfUrl = `https://drive-s.owaf.io/preview/${
    //   user.id
    // }/${space.toLowerCase()}/${fileId}/${
    //   fullName.slice(-1)[0]
    // }?token=${token}&t=${dayjs(record.userFile.updatedAt).format(
    //   "YYYYMMDDHHmmss"
    // )}`;
    const pdfUrl = makeFileUrl({
      urlType: "preview",
      token,
      userId: user.id,
      space: space.toLowerCase(),
      fileId,
      fileName: fullName.slice(-1)[0],
      updateAt: record.userFile.updatedAt,
    });
    // console.log("pdfUrl", pdfUrl);
    isShowBottomPopup.value = true;
    currentPreviewPdfName.value = lastOfArray(fullName);
    isLoadingPdf.value = true;
    //
    // console.log("window", window);
    const PDFjs = (window as any).pdfjsLib as typeof pdfjsLib;
    // console.log("pdfjs", PDFjs);
    PDFjs.GlobalWorkerOptions.workerSrc =
      // "https://cdn.jsdelivr.net/npm/pdfjs-dist@2.10.377/build/pdf.worker.min.js";
      "https://cdn.jsdelivr.net/npm/pdfjs-dist@2.1.266/build/pdf.worker.min.js";
    let viewer: HTMLElement | null;
    let thePdf: PDFDocumentProxy;
    const pdfLoadingTask = PDFjs.getDocument(pdfUrl);
    destoryPdfLoadingTask = () => {
      pdfLoadingTask.destroy();
      destoryPdfLoadingTask = null;
    };
    pdfLoadingTask.promise
      .then((pdf) => {
        isLoadingPdf.value = false;
        useDelay(10).then(async () => {
          viewer = document.getElementById("pdfCanvas");
          thePdf = pdf;
          const renderQueue = [];
          // console.time("ÂÖ®ÈÉ®pdfÈ°µÈù¢Ê∏≤ÊüìÊó∂Èó¥");
          for (let page = 1; page <= pdf.numPages; page++) {
            const canvas = document.createElement("canvas");
            canvas.className = "pdf-page-canvas";
            viewer?.appendChild(canvas);
            // renderPromiseLimit(() => renderPage(page, canvas));
            renderQueue.push(() => renderPage(page, canvas));
          }
          // let i = 0;
          // while (i < renderQueue.length) {
          //   await renderQueue[i]();
          //   i++;
          // }
          renderQueue.reduce((a, b) => a.then(b), Promise.resolve());
        });
      })
      .catch((err) => {
        isLoadingPdf.value = false;
        console.log("Âä†ËΩΩpdfÂá∫Èîô", err);
      });
    const renderPage = async (pageNumber: number, canvas: any) => {
      if (!viewer) {
        // console.log("noViewer");
        return;
      }
      const page = await thePdf.getPage(pageNumber);
      // const unscaledViewport = page.getViewport({ scale: 1 });
      // const scale = viewer.clientWidth / unscaledViewport.width;
      // console.log("calc-scale", scale);
      // https://stackoverflow.com/questions/35400722/pdf-image-quality-is-bad-using-pdf-js
      // Ê∏ÖÊô∞Â∫¶Ëß£ÂÜ≥,ÂÖàÊîæÂ§ß,ÂÜçÁº©Â∞è
      const scale = 2;
      const viewport = page.getViewport({ scale });
      canvas.height = viewport.height;
      canvas.width = viewport.width;
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      // viewer.style.width = Math.floor(viewport.width / scale) + "pt";
      // viewer.style.height = Math.floor(viewport.height / scale) + "pt";
      const renderTask = page.render({
        canvasContext: canvas.getContext("2d"),
        viewport: viewport,
      });
      // console.time(`${pageNumber}`);
      return renderTask.promise.then(() => {
        // console.timeEnd(`${pageNumber}`);
        // if (pageNumber === thePdf.numPages) {
        //   console.timeEnd("ÂÖ®ÈÉ®pdfÈ°µÈù¢Ê∏≤ÊüìÊó∂Èó¥");
        // }
      });
    };
    //
  } else {
    // 3.ÂÖ∂‰ªñÁ±ªÂûã
    // console.log("TODO-ÂÖ∂‰ªñÁ±ªÂûã");
    Toast("‰∏çÊîØÊåÅÈ¢ÑËßàËØ•Êñá‰ª∂");
  }
};
/** ÁÇπÂáªÂêçÂ≠ó */
const onItemNameClick = async (record: ListItem) => {
  // console.log("onItemNameClick");
  const e = record.userFile;
  if (!e) return;
  // Â¶ÇÊûúÊòØÊñá‰ª∂Â§π, Â∞±ËøõÂÖ•Êñá‰ª∂Â§π, Êõ¥Êñ∞Âú∞ÂùÄÊ†èÂíåËØ¶ÊÉÖÊï∞ÊçÆ
  if (e.isDir) {
    historyDir.value.push({
      dirId: e.id,
      dirName: lastOfArray(e.fullName),
    });
    getSetDriveList(e.id);
    setCurrentDescriptionModalData(
      e.id,
      lastOfArray(e.fullName),
      e.info.description || ""
    );
    isShowDescriptionModalFileNameInAddressBar.value = false;
  } else {
    // Â¶ÇÊûúÊòØÊñá‰ª∂, Êõ¥Êñ∞Âà∞Âú∞ÂùÄÊ†è, Âπ∂ËÆæÁΩÆËØ¶ÊÉÖ
    setCurrentDescriptionModalData(
      e.id,
      lastOfArray(e.fullName),
      e.info.description || ""
    );
    isShowDescriptionModalFileNameInAddressBar.value = true;
  }
};

const isShowDescriptionModalFileNameInAddressBar = ref(false);
watch(
  () => isShowDescriptionModalFileNameInAddressBar.value,
  (newVal) => {
    if (newVal) {
      // Â¶ÇÊûúÊñá‰ª∂ÂêçÊòæÁ§∫Âú®Âú∞ÂùÄÊ†è, ÊªëÂä®ÂÆÉËøõÂÖ•ËßÜÂõæ
      useDelay(0).then(scrollLastAddressItemIntoView);
    }
  }
);
const currentDescriptionModalFileName = ref("");
const currentDescription = ref("");
const setCurrentDescriptionModalData = (
  id: string,
  fileName: string,
  descSource: string
) => {
  currentDescriptionModalFileName.value = fileName;
  currentDescription.value = descSource;
  if (!idMapDescriptionCache.has(id)) {
    idMapDescriptionCache.set(id, { fileName, descSource });
  }
};
const setCurrentDescriptionModalDataFromCache = (id: string) => {
  const e = idMapDescriptionCache.get(id);
  if (!e) {
    throw Error(`Ê≤°ÊúâÊâæÂà∞ÊîπÊñá‰ª∂id ${id}ÁöÑÁºìÂ≠ò`);
  }
  const { fileName, descSource } = e;
  currentDescriptionModalFileName.value = fileName;
  currentDescription.value = descSource;
};
const isShowDescriptionPopup = ref(false);
/** recordËØ¶ÁªÜÊèèËø∞‰ø°ÊÅØÁöÑÂºπÁ™ó */
const onShowDescriptionPopup = () => {
  isShowDescriptionPopup.value = true;
};
const onCloseDescriptionPopup = () => {
  isShowDescriptionPopup.value = false;
};

const fileTableRef = ref(null);
/** ÁÇπÂáªÈô§‰∫ÜË°®Ê†ºÁöÑÂÖ∂‰ªñÂú∞Êñπ, ÈáçÁΩÆÂΩìÂâçÁÇπÂáªÈ°π(ËøòÂéüÂú∞ÂùÄÊ†è),Èô§‰∫ÜÂú∞ÂùÄÊ†èÁöÑÊî∂Ëóèicon
 *  Êñá‰ª∂Â§πÁöÑÊÉÖÂÜµ‰∏ãÊâçÂºÄÂêØ, ÂçïÊñá‰ª∂‰∏çÁî®ÂèòÊõ¥Âú∞ÂùÄÊ†èÂíåËØ¶ÊÉÖ
 */
const useClickOutSideWhenShareIsFolder = () => {
  // onClickOutside(fileTableRef, (e) => {
  //   // if (!isShowDescriptionPopup.value) {
  //   // setTimeout(() => {
  //   // console.log("e", e.target);
  //   // Â∑≤ÁªèÊâìÂºÄÂºπÁ™óÁöÑÊÉÖÂÜµ‰∏ã, ‰∏çÈáçÁΩÆÊèèËø∞ÂºπÁ™óÂÜÖÂÆπ
  //   if (isShowDescriptionPopup.value) {
  //     return;
  //   }
  //   isShowDescriptionModalFileNameInAddressBar.value = false;
  //   // ËÆæÁΩÆÂõûÂΩìÂâçÊñá‰ª∂Â§πÁöÑËØ¶ÊÉÖ
  //   const len = historyDir.value.length;
  //   if (len === 1) {
  //     // ÂÖ®ÈÉ®Êñá‰ª∂
  //     setCurrentDescriptionModalDataFromCache(firstFolderDirId);
  //   } else {
  //     // ‰∫å/3Á∫ßÊñá‰ª∂Â§π
  //     setCurrentDescriptionModalDataFromCache(
  //       historyDir.value.length
  //         ? lastOfArray(historyDir.value).dirId
  //         : firstFolderDirId
  //     );
  //   }
  //   // }, 100);
  //   // }
  // });
};
// ÊâãÊú∫ÂØºËà™ÂêéÈÄÄÁöÑÊó∂ÂÄô,Ê£ÄÊü•ÊúâÊ≤°ÂÖàÂÖ≥Èó≠ÂõæÁâáÈ¢ÑËßà
onBeforeRouteLeave((to, from) => {
  if (baseStore.photoSwipe.isShow) {
    baseStore.setPhotoSwipeVisible(false);
    return false;
  }
  return true;
});

const onLikeDonate = () => {
  popupQrCodeVisible.value = false;
}
const popupQrCodeVisible = ref(true)
const popupQrCodeAddr = 'https://www.baidu.com/'
</script>

<style lang="less" scoped>
.fileItem {
  &:active,
  &:hover {
    background: #fafafb;
  }
}
</style>
<style lang="less">
.listLoading {
  position: absolute !important;
  left: 50% !important;
  transform: translateX(-50%) !important;
}
</style>